// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: hyperlane/core/interchain_security/v1/tx.proto

package types

import (
	context "context"
	fmt "fmt"
	github_com_bcp_innovations_hyperlane_cosmos_util "github.com/bcp-innovations/hyperlane-cosmos/util"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/cosmos-sdk/types/msgservice"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MsgCreateMessageIdMultisigIsm ...
type MsgCreateMessageIdMultisigIsm struct {
	// creator is the message sender.
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// validators
	// these are 20 byte long ethereum style addresses
	Validators []string `protobuf:"bytes,2,rep,name=validators,proto3" json:"validators,omitempty"`
	// threshold ...
	Threshold uint32 `protobuf:"varint,3,opt,name=threshold,proto3" json:"threshold,omitempty"`
}

func (m *MsgCreateMessageIdMultisigIsm) Reset()         { *m = MsgCreateMessageIdMultisigIsm{} }
func (m *MsgCreateMessageIdMultisigIsm) String() string { return proto.CompactTextString(m) }
func (*MsgCreateMessageIdMultisigIsm) ProtoMessage()    {}
func (*MsgCreateMessageIdMultisigIsm) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ee100bdd8d27ecb, []int{0}
}
func (m *MsgCreateMessageIdMultisigIsm) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateMessageIdMultisigIsm) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateMessageIdMultisigIsm.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateMessageIdMultisigIsm) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateMessageIdMultisigIsm.Merge(m, src)
}
func (m *MsgCreateMessageIdMultisigIsm) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateMessageIdMultisigIsm) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateMessageIdMultisigIsm.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateMessageIdMultisigIsm proto.InternalMessageInfo

func (m *MsgCreateMessageIdMultisigIsm) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgCreateMessageIdMultisigIsm) GetValidators() []string {
	if m != nil {
		return m.Validators
	}
	return nil
}

func (m *MsgCreateMessageIdMultisigIsm) GetThreshold() uint32 {
	if m != nil {
		return m.Threshold
	}
	return 0
}

// MsgCreateMessageIdMultisigIsmResponse ...
type MsgCreateMessageIdMultisigIsmResponse struct {
	Id github_com_bcp_innovations_hyperlane_cosmos_util.HexAddress `protobuf:"bytes,1,opt,name=id,proto3,customtype=github.com/bcp-innovations/hyperlane-cosmos/util.HexAddress" json:"id"`
}

func (m *MsgCreateMessageIdMultisigIsmResponse) Reset()         { *m = MsgCreateMessageIdMultisigIsmResponse{} }
func (m *MsgCreateMessageIdMultisigIsmResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreateMessageIdMultisigIsmResponse) ProtoMessage()    {}
func (*MsgCreateMessageIdMultisigIsmResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ee100bdd8d27ecb, []int{1}
}
func (m *MsgCreateMessageIdMultisigIsmResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateMessageIdMultisigIsmResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateMessageIdMultisigIsmResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateMessageIdMultisigIsmResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateMessageIdMultisigIsmResponse.Merge(m, src)
}
func (m *MsgCreateMessageIdMultisigIsmResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateMessageIdMultisigIsmResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateMessageIdMultisigIsmResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateMessageIdMultisigIsmResponse proto.InternalMessageInfo

// MsgCreateMerkleRootMultisigIsm ...
type MsgCreateMerkleRootMultisigIsm struct {
	// creator is the message sender.
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// validators
	// these are 20 byte long ethereum style addresses
	Validators []string `protobuf:"bytes,2,rep,name=validators,proto3" json:"validators,omitempty"`
	// threshold ...
	Threshold uint32 `protobuf:"varint,3,opt,name=threshold,proto3" json:"threshold,omitempty"`
}

func (m *MsgCreateMerkleRootMultisigIsm) Reset()         { *m = MsgCreateMerkleRootMultisigIsm{} }
func (m *MsgCreateMerkleRootMultisigIsm) String() string { return proto.CompactTextString(m) }
func (*MsgCreateMerkleRootMultisigIsm) ProtoMessage()    {}
func (*MsgCreateMerkleRootMultisigIsm) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ee100bdd8d27ecb, []int{2}
}
func (m *MsgCreateMerkleRootMultisigIsm) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateMerkleRootMultisigIsm) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateMerkleRootMultisigIsm.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateMerkleRootMultisigIsm) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateMerkleRootMultisigIsm.Merge(m, src)
}
func (m *MsgCreateMerkleRootMultisigIsm) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateMerkleRootMultisigIsm) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateMerkleRootMultisigIsm.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateMerkleRootMultisigIsm proto.InternalMessageInfo

func (m *MsgCreateMerkleRootMultisigIsm) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgCreateMerkleRootMultisigIsm) GetValidators() []string {
	if m != nil {
		return m.Validators
	}
	return nil
}

func (m *MsgCreateMerkleRootMultisigIsm) GetThreshold() uint32 {
	if m != nil {
		return m.Threshold
	}
	return 0
}

// MsgCreateMerkleRootMultisigIsmResponse ...
type MsgCreateMerkleRootMultisigIsmResponse struct {
	Id github_com_bcp_innovations_hyperlane_cosmos_util.HexAddress `protobuf:"bytes,1,opt,name=id,proto3,customtype=github.com/bcp-innovations/hyperlane-cosmos/util.HexAddress" json:"id"`
}

func (m *MsgCreateMerkleRootMultisigIsmResponse) Reset() {
	*m = MsgCreateMerkleRootMultisigIsmResponse{}
}
func (m *MsgCreateMerkleRootMultisigIsmResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreateMerkleRootMultisigIsmResponse) ProtoMessage()    {}
func (*MsgCreateMerkleRootMultisigIsmResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ee100bdd8d27ecb, []int{3}
}
func (m *MsgCreateMerkleRootMultisigIsmResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateMerkleRootMultisigIsmResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateMerkleRootMultisigIsmResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateMerkleRootMultisigIsmResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateMerkleRootMultisigIsmResponse.Merge(m, src)
}
func (m *MsgCreateMerkleRootMultisigIsmResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateMerkleRootMultisigIsmResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateMerkleRootMultisigIsmResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateMerkleRootMultisigIsmResponse proto.InternalMessageInfo

// MsgCreateNoopIsm ...
type MsgCreateNoopIsm struct {
	// creator is the message sender.
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
}

func (m *MsgCreateNoopIsm) Reset()         { *m = MsgCreateNoopIsm{} }
func (m *MsgCreateNoopIsm) String() string { return proto.CompactTextString(m) }
func (*MsgCreateNoopIsm) ProtoMessage()    {}
func (*MsgCreateNoopIsm) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ee100bdd8d27ecb, []int{4}
}
func (m *MsgCreateNoopIsm) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateNoopIsm) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateNoopIsm.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateNoopIsm) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateNoopIsm.Merge(m, src)
}
func (m *MsgCreateNoopIsm) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateNoopIsm) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateNoopIsm.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateNoopIsm proto.InternalMessageInfo

func (m *MsgCreateNoopIsm) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

// MsgCreateNoopIsmResponse ...
type MsgCreateNoopIsmResponse struct {
	Id github_com_bcp_innovations_hyperlane_cosmos_util.HexAddress `protobuf:"bytes,1,opt,name=id,proto3,customtype=github.com/bcp-innovations/hyperlane-cosmos/util.HexAddress" json:"id"`
}

func (m *MsgCreateNoopIsmResponse) Reset()         { *m = MsgCreateNoopIsmResponse{} }
func (m *MsgCreateNoopIsmResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreateNoopIsmResponse) ProtoMessage()    {}
func (*MsgCreateNoopIsmResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ee100bdd8d27ecb, []int{5}
}
func (m *MsgCreateNoopIsmResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateNoopIsmResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateNoopIsmResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateNoopIsmResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateNoopIsmResponse.Merge(m, src)
}
func (m *MsgCreateNoopIsmResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateNoopIsmResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateNoopIsmResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateNoopIsmResponse proto.InternalMessageInfo

// MsgAnnounceValidator ...
type MsgAnnounceValidator struct {
	// validator ...
	Validator string `protobuf:"bytes,1,opt,name=validator,proto3" json:"validator,omitempty"`
	// storage_location ...
	StorageLocation string `protobuf:"bytes,2,opt,name=storage_location,json=storageLocation,proto3" json:"storage_location,omitempty"`
	// signature ...
	Signature string `protobuf:"bytes,3,opt,name=signature,proto3" json:"signature,omitempty"`
	// mailbox_id ...
	MailboxId github_com_bcp_innovations_hyperlane_cosmos_util.HexAddress `protobuf:"bytes,4,opt,name=mailbox_id,json=mailboxId,proto3,customtype=github.com/bcp-innovations/hyperlane-cosmos/util.HexAddress" json:"mailbox_id"`
	// creator ...
	Creator string `protobuf:"bytes,5,opt,name=creator,proto3" json:"creator,omitempty"`
}

func (m *MsgAnnounceValidator) Reset()         { *m = MsgAnnounceValidator{} }
func (m *MsgAnnounceValidator) String() string { return proto.CompactTextString(m) }
func (*MsgAnnounceValidator) ProtoMessage()    {}
func (*MsgAnnounceValidator) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ee100bdd8d27ecb, []int{6}
}
func (m *MsgAnnounceValidator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAnnounceValidator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAnnounceValidator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAnnounceValidator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAnnounceValidator.Merge(m, src)
}
func (m *MsgAnnounceValidator) XXX_Size() int {
	return m.Size()
}
func (m *MsgAnnounceValidator) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAnnounceValidator.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAnnounceValidator proto.InternalMessageInfo

func (m *MsgAnnounceValidator) GetValidator() string {
	if m != nil {
		return m.Validator
	}
	return ""
}

func (m *MsgAnnounceValidator) GetStorageLocation() string {
	if m != nil {
		return m.StorageLocation
	}
	return ""
}

func (m *MsgAnnounceValidator) GetSignature() string {
	if m != nil {
		return m.Signature
	}
	return ""
}

func (m *MsgAnnounceValidator) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

// MsgAnnounceValidatorResponse ...
type MsgAnnounceValidatorResponse struct {
}

func (m *MsgAnnounceValidatorResponse) Reset()         { *m = MsgAnnounceValidatorResponse{} }
func (m *MsgAnnounceValidatorResponse) String() string { return proto.CompactTextString(m) }
func (*MsgAnnounceValidatorResponse) ProtoMessage()    {}
func (*MsgAnnounceValidatorResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ee100bdd8d27ecb, []int{7}
}
func (m *MsgAnnounceValidatorResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAnnounceValidatorResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAnnounceValidatorResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAnnounceValidatorResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAnnounceValidatorResponse.Merge(m, src)
}
func (m *MsgAnnounceValidatorResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgAnnounceValidatorResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAnnounceValidatorResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAnnounceValidatorResponse proto.InternalMessageInfo

// MsgCreateRoutingIsm ...
type MsgCreateRoutingIsm struct {
	// creator ...
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// routes ...
	Routes []Route `protobuf:"bytes,2,rep,name=routes,proto3" json:"routes"`
}

func (m *MsgCreateRoutingIsm) Reset()         { *m = MsgCreateRoutingIsm{} }
func (m *MsgCreateRoutingIsm) String() string { return proto.CompactTextString(m) }
func (*MsgCreateRoutingIsm) ProtoMessage()    {}
func (*MsgCreateRoutingIsm) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ee100bdd8d27ecb, []int{8}
}
func (m *MsgCreateRoutingIsm) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateRoutingIsm) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateRoutingIsm.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateRoutingIsm) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateRoutingIsm.Merge(m, src)
}
func (m *MsgCreateRoutingIsm) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateRoutingIsm) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateRoutingIsm.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateRoutingIsm proto.InternalMessageInfo

func (m *MsgCreateRoutingIsm) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgCreateRoutingIsm) GetRoutes() []Route {
	if m != nil {
		return m.Routes
	}
	return nil
}

// MsgCreateRoutingIsmResponse ...
type MsgCreateRoutingIsmResponse struct {
	Id github_com_bcp_innovations_hyperlane_cosmos_util.HexAddress `protobuf:"bytes,1,opt,name=id,proto3,customtype=github.com/bcp-innovations/hyperlane-cosmos/util.HexAddress" json:"id"`
}

func (m *MsgCreateRoutingIsmResponse) Reset()         { *m = MsgCreateRoutingIsmResponse{} }
func (m *MsgCreateRoutingIsmResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreateRoutingIsmResponse) ProtoMessage()    {}
func (*MsgCreateRoutingIsmResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ee100bdd8d27ecb, []int{9}
}
func (m *MsgCreateRoutingIsmResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateRoutingIsmResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateRoutingIsmResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateRoutingIsmResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateRoutingIsmResponse.Merge(m, src)
}
func (m *MsgCreateRoutingIsmResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateRoutingIsmResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateRoutingIsmResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateRoutingIsmResponse proto.InternalMessageInfo

// MsgSetRoutingIsmDomain ...
type MsgSetRoutingIsmDomain struct {
	// ism_id ...
	IsmId github_com_bcp_innovations_hyperlane_cosmos_util.HexAddress `protobuf:"bytes,1,opt,name=ism_id,json=ismId,proto3,customtype=github.com/bcp-innovations/hyperlane-cosmos/util.HexAddress" json:"ism_id"`
	// route ...
	Route Route `protobuf:"bytes,2,opt,name=route,proto3" json:"route"`
	// owner ...
	Owner string `protobuf:"bytes,3,opt,name=owner,proto3" json:"owner,omitempty"`
}

func (m *MsgSetRoutingIsmDomain) Reset()         { *m = MsgSetRoutingIsmDomain{} }
func (m *MsgSetRoutingIsmDomain) String() string { return proto.CompactTextString(m) }
func (*MsgSetRoutingIsmDomain) ProtoMessage()    {}
func (*MsgSetRoutingIsmDomain) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ee100bdd8d27ecb, []int{10}
}
func (m *MsgSetRoutingIsmDomain) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetRoutingIsmDomain) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetRoutingIsmDomain.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetRoutingIsmDomain) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetRoutingIsmDomain.Merge(m, src)
}
func (m *MsgSetRoutingIsmDomain) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetRoutingIsmDomain) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetRoutingIsmDomain.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetRoutingIsmDomain proto.InternalMessageInfo

func (m *MsgSetRoutingIsmDomain) GetRoute() Route {
	if m != nil {
		return m.Route
	}
	return Route{}
}

func (m *MsgSetRoutingIsmDomain) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

// MsgSetRoutingIsmDomainResponse ...
type MsgSetRoutingIsmDomainResponse struct {
}

func (m *MsgSetRoutingIsmDomainResponse) Reset()         { *m = MsgSetRoutingIsmDomainResponse{} }
func (m *MsgSetRoutingIsmDomainResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSetRoutingIsmDomainResponse) ProtoMessage()    {}
func (*MsgSetRoutingIsmDomainResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ee100bdd8d27ecb, []int{11}
}
func (m *MsgSetRoutingIsmDomainResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetRoutingIsmDomainResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetRoutingIsmDomainResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetRoutingIsmDomainResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetRoutingIsmDomainResponse.Merge(m, src)
}
func (m *MsgSetRoutingIsmDomainResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetRoutingIsmDomainResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetRoutingIsmDomainResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetRoutingIsmDomainResponse proto.InternalMessageInfo

// MsgRemoveRoutingIsmDomain ...
type MsgRemoveRoutingIsmDomain struct {
	// ism_id ...
	IsmId github_com_bcp_innovations_hyperlane_cosmos_util.HexAddress `protobuf:"bytes,1,opt,name=ism_id,json=ismId,proto3,customtype=github.com/bcp-innovations/hyperlane-cosmos/util.HexAddress" json:"ism_id"`
	// domain ...
	Domain uint32 `protobuf:"varint,2,opt,name=domain,proto3" json:"domain,omitempty"`
	// owner ...
	Owner string `protobuf:"bytes,3,opt,name=owner,proto3" json:"owner,omitempty"`
}

func (m *MsgRemoveRoutingIsmDomain) Reset()         { *m = MsgRemoveRoutingIsmDomain{} }
func (m *MsgRemoveRoutingIsmDomain) String() string { return proto.CompactTextString(m) }
func (*MsgRemoveRoutingIsmDomain) ProtoMessage()    {}
func (*MsgRemoveRoutingIsmDomain) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ee100bdd8d27ecb, []int{12}
}
func (m *MsgRemoveRoutingIsmDomain) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRemoveRoutingIsmDomain) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRemoveRoutingIsmDomain.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRemoveRoutingIsmDomain) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRemoveRoutingIsmDomain.Merge(m, src)
}
func (m *MsgRemoveRoutingIsmDomain) XXX_Size() int {
	return m.Size()
}
func (m *MsgRemoveRoutingIsmDomain) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRemoveRoutingIsmDomain.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRemoveRoutingIsmDomain proto.InternalMessageInfo

func (m *MsgRemoveRoutingIsmDomain) GetDomain() uint32 {
	if m != nil {
		return m.Domain
	}
	return 0
}

func (m *MsgRemoveRoutingIsmDomain) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

// MsgRemoveRoutingIsmDomainResponse ...
type MsgRemoveRoutingIsmDomainResponse struct {
}

func (m *MsgRemoveRoutingIsmDomainResponse) Reset()         { *m = MsgRemoveRoutingIsmDomainResponse{} }
func (m *MsgRemoveRoutingIsmDomainResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRemoveRoutingIsmDomainResponse) ProtoMessage()    {}
func (*MsgRemoveRoutingIsmDomainResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ee100bdd8d27ecb, []int{13}
}
func (m *MsgRemoveRoutingIsmDomainResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRemoveRoutingIsmDomainResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRemoveRoutingIsmDomainResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRemoveRoutingIsmDomainResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRemoveRoutingIsmDomainResponse.Merge(m, src)
}
func (m *MsgRemoveRoutingIsmDomainResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRemoveRoutingIsmDomainResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRemoveRoutingIsmDomainResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRemoveRoutingIsmDomainResponse proto.InternalMessageInfo

// MsgUpdateRoutingIsmOwner ...
type MsgUpdateRoutingIsmOwner struct {
	// ism_id ...
	IsmId github_com_bcp_innovations_hyperlane_cosmos_util.HexAddress `protobuf:"bytes,1,opt,name=ism_id,json=ismId,proto3,customtype=github.com/bcp-innovations/hyperlane-cosmos/util.HexAddress" json:"ism_id"`
	// owner ...
	Owner string `protobuf:"bytes,2,opt,name=owner,proto3" json:"owner,omitempty"`
	// new owner
	NewOwner string `protobuf:"bytes,3,opt,name=new_owner,json=newOwner,proto3" json:"new_owner,omitempty"`
	// renounce_ownership
	RenounceOwnership bool `protobuf:"varint,4,opt,name=renounce_ownership,json=renounceOwnership,proto3" json:"renounce_ownership,omitempty"`
}

func (m *MsgUpdateRoutingIsmOwner) Reset()         { *m = MsgUpdateRoutingIsmOwner{} }
func (m *MsgUpdateRoutingIsmOwner) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateRoutingIsmOwner) ProtoMessage()    {}
func (*MsgUpdateRoutingIsmOwner) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ee100bdd8d27ecb, []int{14}
}
func (m *MsgUpdateRoutingIsmOwner) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateRoutingIsmOwner) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateRoutingIsmOwner.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateRoutingIsmOwner) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateRoutingIsmOwner.Merge(m, src)
}
func (m *MsgUpdateRoutingIsmOwner) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateRoutingIsmOwner) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateRoutingIsmOwner.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateRoutingIsmOwner proto.InternalMessageInfo

func (m *MsgUpdateRoutingIsmOwner) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *MsgUpdateRoutingIsmOwner) GetNewOwner() string {
	if m != nil {
		return m.NewOwner
	}
	return ""
}

func (m *MsgUpdateRoutingIsmOwner) GetRenounceOwnership() bool {
	if m != nil {
		return m.RenounceOwnership
	}
	return false
}

// MsgUpdateRoutingIsmOwnerResponse ...
type MsgUpdateRoutingIsmOwnerResponse struct {
}

func (m *MsgUpdateRoutingIsmOwnerResponse) Reset()         { *m = MsgUpdateRoutingIsmOwnerResponse{} }
func (m *MsgUpdateRoutingIsmOwnerResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateRoutingIsmOwnerResponse) ProtoMessage()    {}
func (*MsgUpdateRoutingIsmOwnerResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ee100bdd8d27ecb, []int{15}
}
func (m *MsgUpdateRoutingIsmOwnerResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateRoutingIsmOwnerResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateRoutingIsmOwnerResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateRoutingIsmOwnerResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateRoutingIsmOwnerResponse.Merge(m, src)
}
func (m *MsgUpdateRoutingIsmOwnerResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateRoutingIsmOwnerResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateRoutingIsmOwnerResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateRoutingIsmOwnerResponse proto.InternalMessageInfo

// MsgCreateAggregationIsm creates an Aggregation ISM that verifies messages by
// requiring a threshold number of child ISMs to pass verification (M-of-N
// pattern).
type MsgCreateAggregationIsm struct {
	// creator is the address that will become the owner of the ISM
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// modules is the list of child ISM IDs to aggregate
	Modules []github_com_bcp_innovations_hyperlane_cosmos_util.HexAddress `protobuf:"bytes,2,rep,name=modules,proto3,customtype=github.com/bcp-innovations/hyperlane-cosmos/util.HexAddress" json:"modules"`
	// threshold is the number of child ISMs that must pass (must be > 0 and <=
	// len(modules))
	Threshold uint32 `protobuf:"varint,3,opt,name=threshold,proto3" json:"threshold,omitempty"`
}

func (m *MsgCreateAggregationIsm) Reset()         { *m = MsgCreateAggregationIsm{} }
func (m *MsgCreateAggregationIsm) String() string { return proto.CompactTextString(m) }
func (*MsgCreateAggregationIsm) ProtoMessage()    {}
func (*MsgCreateAggregationIsm) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ee100bdd8d27ecb, []int{16}
}
func (m *MsgCreateAggregationIsm) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateAggregationIsm) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateAggregationIsm.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateAggregationIsm) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateAggregationIsm.Merge(m, src)
}
func (m *MsgCreateAggregationIsm) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateAggregationIsm) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateAggregationIsm.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateAggregationIsm proto.InternalMessageInfo

func (m *MsgCreateAggregationIsm) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgCreateAggregationIsm) GetThreshold() uint32 {
	if m != nil {
		return m.Threshold
	}
	return 0
}

// MsgCreateAggregationIsmResponse returns the ID of the newly created
// Aggregation ISM
type MsgCreateAggregationIsmResponse struct {
	// id is the unique identifier of the created Aggregation ISM
	Id github_com_bcp_innovations_hyperlane_cosmos_util.HexAddress `protobuf:"bytes,1,opt,name=id,proto3,customtype=github.com/bcp-innovations/hyperlane-cosmos/util.HexAddress" json:"id"`
}

func (m *MsgCreateAggregationIsmResponse) Reset()         { *m = MsgCreateAggregationIsmResponse{} }
func (m *MsgCreateAggregationIsmResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreateAggregationIsmResponse) ProtoMessage()    {}
func (*MsgCreateAggregationIsmResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ee100bdd8d27ecb, []int{17}
}
func (m *MsgCreateAggregationIsmResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateAggregationIsmResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateAggregationIsmResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateAggregationIsmResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateAggregationIsmResponse.Merge(m, src)
}
func (m *MsgCreateAggregationIsmResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateAggregationIsmResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateAggregationIsmResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateAggregationIsmResponse proto.InternalMessageInfo

// MsgSetAggregationIsmModules updates the child ISMs and threshold of an
// existing Aggregation ISM. Only the current owner can execute this operation.
type MsgSetAggregationIsmModules struct {
	// ism_id is the identifier of the Aggregation ISM to update
	IsmId github_com_bcp_innovations_hyperlane_cosmos_util.HexAddress `protobuf:"bytes,1,opt,name=ism_id,json=ismId,proto3,customtype=github.com/bcp-innovations/hyperlane-cosmos/util.HexAddress" json:"ism_id"`
	// modules is the new list of child ISM IDs to aggregate
	Modules []github_com_bcp_innovations_hyperlane_cosmos_util.HexAddress `protobuf:"bytes,2,rep,name=modules,proto3,customtype=github.com/bcp-innovations/hyperlane-cosmos/util.HexAddress" json:"modules"`
	// threshold is the new number of child ISMs that must pass verification
	Threshold uint32 `protobuf:"varint,3,opt,name=threshold,proto3" json:"threshold,omitempty"`
	// owner is the current owner address (must match the ISM's owner)
	Owner string `protobuf:"bytes,4,opt,name=owner,proto3" json:"owner,omitempty"`
}

func (m *MsgSetAggregationIsmModules) Reset()         { *m = MsgSetAggregationIsmModules{} }
func (m *MsgSetAggregationIsmModules) String() string { return proto.CompactTextString(m) }
func (*MsgSetAggregationIsmModules) ProtoMessage()    {}
func (*MsgSetAggregationIsmModules) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ee100bdd8d27ecb, []int{18}
}
func (m *MsgSetAggregationIsmModules) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetAggregationIsmModules) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetAggregationIsmModules.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetAggregationIsmModules) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetAggregationIsmModules.Merge(m, src)
}
func (m *MsgSetAggregationIsmModules) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetAggregationIsmModules) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetAggregationIsmModules.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetAggregationIsmModules proto.InternalMessageInfo

func (m *MsgSetAggregationIsmModules) GetThreshold() uint32 {
	if m != nil {
		return m.Threshold
	}
	return 0
}

func (m *MsgSetAggregationIsmModules) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

// MsgSetAggregationIsmModulesResponse ...
type MsgSetAggregationIsmModulesResponse struct {
}

func (m *MsgSetAggregationIsmModulesResponse) Reset()         { *m = MsgSetAggregationIsmModulesResponse{} }
func (m *MsgSetAggregationIsmModulesResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSetAggregationIsmModulesResponse) ProtoMessage()    {}
func (*MsgSetAggregationIsmModulesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ee100bdd8d27ecb, []int{19}
}
func (m *MsgSetAggregationIsmModulesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetAggregationIsmModulesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetAggregationIsmModulesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetAggregationIsmModulesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetAggregationIsmModulesResponse.Merge(m, src)
}
func (m *MsgSetAggregationIsmModulesResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetAggregationIsmModulesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetAggregationIsmModulesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetAggregationIsmModulesResponse proto.InternalMessageInfo

// MsgUpdateAggregationIsmOwner transfers ownership of an Aggregation ISM to a
// new address or renounces ownership entirely. Only the current owner can
// execute this.
type MsgUpdateAggregationIsmOwner struct {
	// ism_id is the identifier of the Aggregation ISM
	IsmId github_com_bcp_innovations_hyperlane_cosmos_util.HexAddress `protobuf:"bytes,1,opt,name=ism_id,json=ismId,proto3,customtype=github.com/bcp-innovations/hyperlane-cosmos/util.HexAddress" json:"ism_id"`
	// owner is the current owner address (must match the ISM's owner)
	Owner string `protobuf:"bytes,2,opt,name=owner,proto3" json:"owner,omitempty"`
	// new_owner is the address to transfer ownership to (ignored if
	// renounce_ownership is true)
	NewOwner string `protobuf:"bytes,3,opt,name=new_owner,json=newOwner,proto3" json:"new_owner,omitempty"`
	// renounce_ownership removes ownership permanently if true (new_owner must be
	// empty)
	RenounceOwnership bool `protobuf:"varint,4,opt,name=renounce_ownership,json=renounceOwnership,proto3" json:"renounce_ownership,omitempty"`
}

func (m *MsgUpdateAggregationIsmOwner) Reset()         { *m = MsgUpdateAggregationIsmOwner{} }
func (m *MsgUpdateAggregationIsmOwner) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateAggregationIsmOwner) ProtoMessage()    {}
func (*MsgUpdateAggregationIsmOwner) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ee100bdd8d27ecb, []int{20}
}
func (m *MsgUpdateAggregationIsmOwner) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateAggregationIsmOwner) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateAggregationIsmOwner.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateAggregationIsmOwner) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateAggregationIsmOwner.Merge(m, src)
}
func (m *MsgUpdateAggregationIsmOwner) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateAggregationIsmOwner) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateAggregationIsmOwner.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateAggregationIsmOwner proto.InternalMessageInfo

func (m *MsgUpdateAggregationIsmOwner) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *MsgUpdateAggregationIsmOwner) GetNewOwner() string {
	if m != nil {
		return m.NewOwner
	}
	return ""
}

func (m *MsgUpdateAggregationIsmOwner) GetRenounceOwnership() bool {
	if m != nil {
		return m.RenounceOwnership
	}
	return false
}

// MsgUpdateAggregationIsmOwnerResponse ...
type MsgUpdateAggregationIsmOwnerResponse struct {
}

func (m *MsgUpdateAggregationIsmOwnerResponse) Reset()         { *m = MsgUpdateAggregationIsmOwnerResponse{} }
func (m *MsgUpdateAggregationIsmOwnerResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateAggregationIsmOwnerResponse) ProtoMessage()    {}
func (*MsgUpdateAggregationIsmOwnerResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ee100bdd8d27ecb, []int{21}
}
func (m *MsgUpdateAggregationIsmOwnerResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateAggregationIsmOwnerResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateAggregationIsmOwnerResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateAggregationIsmOwnerResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateAggregationIsmOwnerResponse.Merge(m, src)
}
func (m *MsgUpdateAggregationIsmOwnerResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateAggregationIsmOwnerResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateAggregationIsmOwnerResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateAggregationIsmOwnerResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*MsgCreateMessageIdMultisigIsm)(nil), "hyperlane.core.interchain_security.v1.MsgCreateMessageIdMultisigIsm")
	proto.RegisterType((*MsgCreateMessageIdMultisigIsmResponse)(nil), "hyperlane.core.interchain_security.v1.MsgCreateMessageIdMultisigIsmResponse")
	proto.RegisterType((*MsgCreateMerkleRootMultisigIsm)(nil), "hyperlane.core.interchain_security.v1.MsgCreateMerkleRootMultisigIsm")
	proto.RegisterType((*MsgCreateMerkleRootMultisigIsmResponse)(nil), "hyperlane.core.interchain_security.v1.MsgCreateMerkleRootMultisigIsmResponse")
	proto.RegisterType((*MsgCreateNoopIsm)(nil), "hyperlane.core.interchain_security.v1.MsgCreateNoopIsm")
	proto.RegisterType((*MsgCreateNoopIsmResponse)(nil), "hyperlane.core.interchain_security.v1.MsgCreateNoopIsmResponse")
	proto.RegisterType((*MsgAnnounceValidator)(nil), "hyperlane.core.interchain_security.v1.MsgAnnounceValidator")
	proto.RegisterType((*MsgAnnounceValidatorResponse)(nil), "hyperlane.core.interchain_security.v1.MsgAnnounceValidatorResponse")
	proto.RegisterType((*MsgCreateRoutingIsm)(nil), "hyperlane.core.interchain_security.v1.MsgCreateRoutingIsm")
	proto.RegisterType((*MsgCreateRoutingIsmResponse)(nil), "hyperlane.core.interchain_security.v1.MsgCreateRoutingIsmResponse")
	proto.RegisterType((*MsgSetRoutingIsmDomain)(nil), "hyperlane.core.interchain_security.v1.MsgSetRoutingIsmDomain")
	proto.RegisterType((*MsgSetRoutingIsmDomainResponse)(nil), "hyperlane.core.interchain_security.v1.MsgSetRoutingIsmDomainResponse")
	proto.RegisterType((*MsgRemoveRoutingIsmDomain)(nil), "hyperlane.core.interchain_security.v1.MsgRemoveRoutingIsmDomain")
	proto.RegisterType((*MsgRemoveRoutingIsmDomainResponse)(nil), "hyperlane.core.interchain_security.v1.MsgRemoveRoutingIsmDomainResponse")
	proto.RegisterType((*MsgUpdateRoutingIsmOwner)(nil), "hyperlane.core.interchain_security.v1.MsgUpdateRoutingIsmOwner")
	proto.RegisterType((*MsgUpdateRoutingIsmOwnerResponse)(nil), "hyperlane.core.interchain_security.v1.MsgUpdateRoutingIsmOwnerResponse")
	proto.RegisterType((*MsgCreateAggregationIsm)(nil), "hyperlane.core.interchain_security.v1.MsgCreateAggregationIsm")
	proto.RegisterType((*MsgCreateAggregationIsmResponse)(nil), "hyperlane.core.interchain_security.v1.MsgCreateAggregationIsmResponse")
	proto.RegisterType((*MsgSetAggregationIsmModules)(nil), "hyperlane.core.interchain_security.v1.MsgSetAggregationIsmModules")
	proto.RegisterType((*MsgSetAggregationIsmModulesResponse)(nil), "hyperlane.core.interchain_security.v1.MsgSetAggregationIsmModulesResponse")
	proto.RegisterType((*MsgUpdateAggregationIsmOwner)(nil), "hyperlane.core.interchain_security.v1.MsgUpdateAggregationIsmOwner")
	proto.RegisterType((*MsgUpdateAggregationIsmOwnerResponse)(nil), "hyperlane.core.interchain_security.v1.MsgUpdateAggregationIsmOwnerResponse")
}

func init() {
	proto.RegisterFile("hyperlane/core/interchain_security/v1/tx.proto", fileDescriptor_4ee100bdd8d27ecb)
}

var fileDescriptor_4ee100bdd8d27ecb = []byte{
	// 1209 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x58, 0x5f, 0x6f, 0x1b, 0x45,
	0x10, 0xcf, 0xba, 0x4d, 0x5a, 0x0f, 0x0a, 0x24, 0xd7, 0x90, 0x3a, 0xd7, 0xd6, 0x71, 0x2f, 0x4d,
	0x94, 0x06, 0x72, 0xc6, 0x81, 0xa8, 0x28, 0xe1, 0x5f, 0x9c, 0x16, 0x92, 0x52, 0x13, 0xe9, 0x22,
	0x78, 0xa8, 0x40, 0x96, 0xe3, 0x5b, 0x9d, 0x57, 0xf8, 0x6e, 0xad, 0xdb, 0xb3, 0x93, 0x48, 0x20,
	0x01, 0x4f, 0xc0, 0x13, 0x42, 0xea, 0x13, 0x12, 0x12, 0x12, 0x0f, 0x08, 0x09, 0x88, 0x44, 0xc5,
	0x67, 0xa8, 0x78, 0xaa, 0x78, 0x42, 0x08, 0x15, 0x94, 0x3c, 0xe4, 0x6b, 0xa0, 0xfb, 0xe3, 0x75,
	0xee, 0xb2, 0x76, 0xec, 0xd8, 0x0e, 0x2f, 0x96, 0x77, 0x66, 0xe7, 0x37, 0x33, 0xbf, 0x99, 0x9d,
	0xdb, 0x3b, 0x50, 0x4b, 0xbb, 0x15, 0x6c, 0x97, 0x0b, 0x16, 0x4e, 0x17, 0xa9, 0x8d, 0xd3, 0xc4,
	0x72, 0xb0, 0x5d, 0x2c, 0x15, 0x88, 0x95, 0x67, 0xb8, 0x58, 0xb5, 0x89, 0xb3, 0x9b, 0xae, 0x65,
	0xd2, 0xce, 0x8e, 0x5a, 0xb1, 0xa9, 0x43, 0xa5, 0x69, 0xbe, 0x5f, 0x75, 0xf7, 0xab, 0x82, 0xfd,
	0x6a, 0x2d, 0x23, 0x4f, 0x14, 0x29, 0x33, 0x29, 0xcb, 0x7b, 0x46, 0x69, 0x7f, 0xe1, 0x23, 0xc8,
	0x97, 0xfd, 0x55, 0xda, 0x64, 0x86, 0x8b, 0x6c, 0x32, 0x23, 0x50, 0x8c, 0x16, 0x4c, 0x62, 0xd1,
	0xb4, 0xf7, 0x1b, 0x88, 0x32, 0x6d, 0x46, 0xb7, 0x5b, 0xc1, 0x75, 0xf8, 0x31, 0x83, 0x1a, 0xd4,
	0x77, 0xeb, 0xfe, 0xf3, 0xa5, 0xca, 0x43, 0x04, 0xd7, 0x72, 0xcc, 0x58, 0xb5, 0x71, 0xc1, 0xc1,
	0x39, 0xcc, 0x58, 0xc1, 0xc0, 0xeb, 0x7a, 0xae, 0x5a, 0x76, 0x08, 0x23, 0xc6, 0x3a, 0x33, 0xa5,
	0x04, 0x5c, 0x28, 0xba, 0x5a, 0x6a, 0x27, 0x50, 0x0a, 0xcd, 0xc6, 0xb5, 0xfa, 0x52, 0x4a, 0x02,
	0xd4, 0x0a, 0x65, 0xa2, 0xbb, 0x0b, 0x96, 0x88, 0xa5, 0xce, 0xcd, 0xc6, 0xb5, 0x23, 0x12, 0xe9,
	0x2a, 0xc4, 0x9d, 0x92, 0x8d, 0x59, 0x89, 0x96, 0xf5, 0xc4, 0xb9, 0x14, 0x9a, 0x1d, 0xd6, 0x1a,
	0x82, 0xa5, 0xe5, 0xcf, 0x0e, 0xf7, 0xe6, 0xea, 0x58, 0x5f, 0x1e, 0xee, 0xcd, 0xcd, 0x35, 0x72,
	0xaa, 0x65, 0xd2, 0x2d, 0x83, 0x52, 0x3e, 0x82, 0xe9, 0x96, 0x1b, 0x34, 0xcc, 0x2a, 0xd4, 0x62,
	0x58, 0xda, 0x84, 0x18, 0xd1, 0xfd, 0xc0, 0xb3, 0xab, 0x8f, 0x9e, 0x4c, 0x0e, 0xfc, 0xf5, 0x64,
	0x72, 0xd9, 0x20, 0x4e, 0xa9, 0xba, 0xa5, 0x16, 0xa9, 0x99, 0xde, 0x2a, 0x56, 0xe6, 0x89, 0x65,
	0xd1, 0x5a, 0xc1, 0x21, 0xd4, 0x62, 0x69, 0x1e, 0xc3, 0x7c, 0x50, 0x8d, 0xaa, 0x43, 0xca, 0xea,
	0x1a, 0xde, 0x59, 0xd1, 0x75, 0x1b, 0x33, 0xa6, 0xc5, 0x88, 0xae, 0xfc, 0x86, 0x20, 0x79, 0xc4,
	0xbd, 0xfd, 0x61, 0x19, 0x6b, 0x94, 0x3a, 0x67, 0xc1, 0xda, 0x2b, 0x51, 0xd6, 0x9e, 0x6b, 0xc6,
	0x9a, 0x20, 0x2a, 0xe5, 0x63, 0x98, 0x69, 0xbd, 0xa3, 0xbf, 0xbc, 0xbd, 0x0f, 0x23, 0xdc, 0xfd,
	0x3b, 0x94, 0x56, 0x5a, 0x12, 0xb5, 0xa4, 0x46, 0x53, 0xbd, 0x26, 0x4e, 0x35, 0x40, 0x52, 0x28,
	0x24, 0xa2, 0xb2, 0xfe, 0xa6, 0xf3, 0x4b, 0x0c, 0xc6, 0x72, 0xcc, 0x58, 0xb1, 0x2c, 0x5a, 0xb5,
	0x8a, 0xf8, 0xbd, 0x7a, 0x0d, 0xdd, 0x12, 0xf2, 0x82, 0x06, 0x59, 0x35, 0x04, 0xd2, 0x4d, 0x18,
	0x61, 0x0e, 0xb5, 0x0b, 0x06, 0xce, 0x97, 0x69, 0xd1, 0x73, 0x98, 0x88, 0x79, 0x9b, 0x9e, 0x09,
	0xe4, 0xf7, 0x02, 0xb1, 0x0b, 0xc4, 0x88, 0x61, 0x15, 0x9c, 0xaa, 0x8d, 0xbd, 0x5e, 0x88, 0x6b,
	0x0d, 0x81, 0xb4, 0x05, 0x60, 0x16, 0x48, 0x79, 0x8b, 0xee, 0xe4, 0x89, 0x9e, 0x38, 0xdf, 0xbb,
	0xe4, 0xe2, 0x01, 0xec, 0xba, 0x7e, 0xb4, 0x3c, 0x83, 0xe1, 0xf2, 0x2c, 0x44, 0xcb, 0x73, 0x3d,
	0x5a, 0x9e, 0x63, 0xc4, 0x28, 0x49, 0xb8, 0x2a, 0x92, 0xd7, 0xcb, 0xa4, 0xfc, 0x8c, 0xe0, 0x12,
	0xaf, 0xa1, 0x46, 0xab, 0x0e, 0xb1, 0x4e, 0x38, 0x4d, 0x77, 0x61, 0xc8, 0xa6, 0x55, 0x07, 0xfb,
	0x27, 0xe9, 0xa9, 0x85, 0xe7, 0xd5, 0xb6, 0xe6, 0xb0, 0xea, 0x82, 0xe3, 0xec, 0x79, 0x97, 0x2d,
	0x2d, 0x40, 0x58, 0xca, 0x44, 0x33, 0x4a, 0x89, 0x1b, 0xae, 0x11, 0x98, 0x62, 0xc3, 0x15, 0x81,
	0xb8, 0xbf, 0x6d, 0xf7, 0x79, 0x0c, 0xc6, 0x73, 0xcc, 0xd8, 0xc4, 0x4e, 0xc3, 0xe3, 0x6d, 0x6a,
	0x16, 0x88, 0x25, 0xdd, 0x87, 0x21, 0xc2, 0xcc, 0x7c, 0x6f, 0x7d, 0x0e, 0x12, 0x66, 0xae, 0xeb,
	0xd2, 0x1a, 0x0c, 0x7a, 0x3c, 0x79, 0xbd, 0x7a, 0x3a, 0xa2, 0x7d, 0x00, 0x69, 0x0c, 0x06, 0xe9,
	0xb6, 0x85, 0xed, 0xa0, 0xa3, 0xfd, 0x85, 0xdf, 0x4f, 0xfe, 0x7f, 0x97, 0xfb, 0xa9, 0x28, 0xf7,
	0x82, 0x7c, 0x95, 0x94, 0x37, 0x87, 0x05, 0x1a, 0xde, 0x51, 0x7f, 0x23, 0x98, 0xc8, 0x31, 0x43,
	0xc3, 0x26, 0xad, 0xe1, 0x33, 0xe5, 0x6b, 0x1c, 0x86, 0x74, 0xcf, 0x8b, 0x47, 0xd8, 0xb0, 0x16,
	0xac, 0x9a, 0x64, 0xbf, 0x18, 0xce, 0x7e, 0x26, 0x9a, 0xbd, 0x38, 0x01, 0x65, 0x0a, 0xae, 0x37,
	0x55, 0x72, 0x0e, 0x7e, 0x88, 0x79, 0x93, 0xf1, 0xdd, 0x8a, 0x1e, 0xea, 0xd2, 0x0d, 0xd7, 0x59,
	0x5f, 0x29, 0xe0, 0xa9, 0xc6, 0x8e, 0xa4, 0x2a, 0x2d, 0x42, 0xdc, 0xc2, 0xdb, 0xf9, 0x23, 0x24,
	0x64, 0x13, 0x7f, 0x3c, 0x9c, 0x1f, 0x0b, 0x2e, 0x43, 0x01, 0xc6, 0xa6, 0x63, 0x13, 0xcb, 0xd0,
	0x2e, 0x5a, 0x78, 0xdb, 0x0f, 0x74, 0x1e, 0x24, 0x1b, 0xfb, 0x83, 0xc3, 0xb7, 0x65, 0x25, 0x52,
	0xf1, 0xa6, 0xde, 0x45, 0x6d, 0xb4, 0xae, 0xd9, 0xa8, 0x2b, 0x96, 0x5e, 0x0a, 0x13, 0x3a, 0x1d,
	0x25, 0x54, 0xc8, 0x86, 0xa2, 0x40, 0xaa, 0x99, 0x8e, 0xd3, 0xf9, 0x69, 0x0c, 0x2e, 0xf3, 0x43,
	0xbf, 0x62, 0x18, 0x36, 0x36, 0x3c, 0x5e, 0xdc, 0x41, 0xb5, 0x10, 0x19, 0x54, 0x2d, 0x32, 0xe3,
	0x23, 0xec, 0x03, 0xb8, 0x60, 0x52, 0xbd, 0x5a, 0x0e, 0x66, 0x58, 0x8f, 0x4a, 0x50, 0xc7, 0x3c,
	0xe1, 0x3e, 0xb1, 0x18, 0x9d, 0x79, 0x37, 0xc4, 0x33, 0x2f, 0x9c, 0xa7, 0x52, 0x83, 0xc9, 0x26,
	0xaa, 0xfe, 0xce, 0xbe, 0x7f, 0x62, 0xde, 0xc0, 0xdd, 0xc4, 0x4e, 0xd8, 0x6b, 0x2e, 0x48, 0xb6,
	0x9f, 0xdd, 0xfc, 0x7f, 0xd6, 0x49, 0x52, 0xeb, 0x47, 0xe9, 0xfc, 0x09, 0x6d, 0x15, 0xcc, 0x93,
	0x5b, 0xe1, 0xf6, 0x9f, 0x15, 0x4c, 0x53, 0x21, 0x83, 0xca, 0x34, 0x4c, 0xb5, 0x50, 0xf3, 0x43,
	0xf0, 0x7b, 0xcc, 0x7b, 0x94, 0xfb, 0x27, 0x25, 0xbc, 0xb5, 0xff, 0x73, 0x45, 0x0d, 0xcd, 0x95,
	0x13, 0xc9, 0x38, 0xa3, 0x89, 0xf3, 0x72, 0x98, 0xf2, 0x9b, 0xe2, 0x89, 0x23, 0xe0, 0x4a, 0x99,
	0x81, 0x1b, 0xad, 0xf4, 0x75, 0xd2, 0x17, 0x1e, 0x3c, 0x0d, 0xe7, 0x72, 0xcc, 0x90, 0xf6, 0x10,
	0xc8, 0x2d, 0xde, 0xd8, 0x6e, 0xb7, 0xf9, 0x68, 0x6e, 0xf9, 0x06, 0x25, 0xdf, 0xeb, 0x05, 0x0a,
	0x9f, 0x06, 0xbf, 0x22, 0xb8, 0xd2, 0xea, 0x7d, 0xe9, 0x4e, 0xe7, 0xde, 0x04, 0x30, 0x72, 0xae,
	0x27, 0x30, 0x3c, 0xea, 0x2f, 0x10, 0x0c, 0x87, 0x5f, 0x57, 0x6e, 0x75, 0xea, 0x20, 0x30, 0x94,
	0x5f, 0x3f, 0xa5, 0x21, 0x8f, 0xe5, 0x6b, 0x04, 0x23, 0xc7, 0x2e, 0xc6, 0x4b, 0x9d, 0xa2, 0x36,
	0x6c, 0xe5, 0xec, 0xe9, 0x6d, 0x79, 0x50, 0xdf, 0x20, 0xb8, 0x24, 0xba, 0x88, 0xbe, 0xda, 0x3e,
	0xb6, 0xc0, 0x5c, 0xbe, 0xd3, 0x95, 0x39, 0x8f, 0xee, 0x7b, 0x04, 0xe3, 0x4d, 0x6e, 0x7e, 0x6f,
	0xb4, 0xef, 0x41, 0x8c, 0x20, 0xaf, 0x75, 0x8b, 0xc0, 0xc3, 0xfc, 0x0e, 0xc1, 0xb3, 0xe2, 0xcb,
	0x59, 0x07, 0x4d, 0x23, 0x04, 0x90, 0xdf, 0xea, 0x12, 0x80, 0xc7, 0xf8, 0x00, 0xc1, 0xe8, 0xf1,
	0x17, 0xdd, 0xe5, 0xf6, 0xe1, 0x8f, 0x19, 0xcb, 0xab, 0x5d, 0x18, 0xf3, 0xb8, 0xbe, 0x45, 0x30,
	0x26, 0xbc, 0x89, 0xbd, 0xd6, 0x69, 0x77, 0x87, 0xed, 0xe5, 0x37, 0xbb, 0xb3, 0xe7, 0x01, 0xfe,
	0x88, 0x20, 0xd1, 0xf4, 0xba, 0x92, 0xed, 0xa8, 0xcf, 0x85, 0x18, 0xf2, 0xdd, 0xee, 0x31, 0x78,
	0xb0, 0x3f, 0x21, 0x98, 0x68, 0xfe, 0x48, 0x5f, 0xed, 0xb4, 0x99, 0x04, 0x20, 0xf2, 0xdb, 0x3d,
	0x00, 0xa9, 0xc7, 0x2b, 0x0f, 0x7e, 0x72, 0xb8, 0x37, 0x87, 0xb2, 0xe4, 0xd1, 0x7e, 0x12, 0x3d,
	0xde, 0x4f, 0xa2, 0x7f, 0xf7, 0x93, 0xe8, 0xab, 0x83, 0xe4, 0xc0, 0xe3, 0x83, 0xe4, 0xc0, 0x9f,
	0x07, 0xc9, 0x81, 0xfb, 0x1b, 0x9d, 0xdc, 0x36, 0x76, 0xfc, 0x6f, 0xa9, 0x2f, 0x64, 0xf2, 0xa2,
	0xcf, 0xa9, 0xde, 0xb7, 0xd4, 0xad, 0x21, 0xef, 0xb3, 0xe9, 0x8b, 0xff, 0x05, 0x00, 0x00, 0xff,
	0xff, 0x68, 0x6b, 0x1e, 0x6b, 0x1f, 0x16, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
	// CreateMessageIdMultisigIsm ...
	CreateMessageIdMultisigIsm(ctx context.Context, in *MsgCreateMessageIdMultisigIsm, opts ...grpc.CallOption) (*MsgCreateMessageIdMultisigIsmResponse, error)
	// CreateMerkleRootMultisigIsm ...
	CreateMerkleRootMultisigIsm(ctx context.Context, in *MsgCreateMerkleRootMultisigIsm, opts ...grpc.CallOption) (*MsgCreateMerkleRootMultisigIsmResponse, error)
	// CreateNoopIsm ...
	CreateNoopIsm(ctx context.Context, in *MsgCreateNoopIsm, opts ...grpc.CallOption) (*MsgCreateNoopIsmResponse, error)
	// CreateRoutingIsm ...
	CreateRoutingIsm(ctx context.Context, in *MsgCreateRoutingIsm, opts ...grpc.CallOption) (*MsgCreateRoutingIsmResponse, error)
	// SetRoutingIsmDomain ...
	SetRoutingIsmDomain(ctx context.Context, in *MsgSetRoutingIsmDomain, opts ...grpc.CallOption) (*MsgSetRoutingIsmDomainResponse, error)
	// RemoveRoutingIsmDomain ...
	RemoveRoutingIsmDomain(ctx context.Context, in *MsgRemoveRoutingIsmDomain, opts ...grpc.CallOption) (*MsgRemoveRoutingIsmDomainResponse, error)
	// UpdateRoutingIsmOwner ...
	UpdateRoutingIsmOwner(ctx context.Context, in *MsgUpdateRoutingIsmOwner, opts ...grpc.CallOption) (*MsgUpdateRoutingIsmOwnerResponse, error)
	// AnnounceValidator ...
	AnnounceValidator(ctx context.Context, in *MsgAnnounceValidator, opts ...grpc.CallOption) (*MsgAnnounceValidatorResponse, error)
	// CreateAggregationIsm creates a new Aggregation ISM that requires a
	// threshold of child ISMs to pass verification. The creator becomes the owner
	// of the ISM. Emits EventCreateAggregationIsm on success.
	CreateAggregationIsm(ctx context.Context, in *MsgCreateAggregationIsm, opts ...grpc.CallOption) (*MsgCreateAggregationIsmResponse, error)
	// SetAggregationIsmModules updates the modules and threshold of an existing
	// Aggregation ISM. Only the owner can perform this operation.
	// Emits EventSetAggregationIsmModules on success.
	SetAggregationIsmModules(ctx context.Context, in *MsgSetAggregationIsmModules, opts ...grpc.CallOption) (*MsgSetAggregationIsmModulesResponse, error)
	// UpdateAggregationIsmOwner transfers ownership of an Aggregation ISM to a
	// new address or renounces ownership entirely. Only the current owner can
	// perform this operation. Emits EventSetAggregationIsm on success.
	UpdateAggregationIsmOwner(ctx context.Context, in *MsgUpdateAggregationIsmOwner, opts ...grpc.CallOption) (*MsgUpdateAggregationIsmOwnerResponse, error)
}

type msgClient struct {
	cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) CreateMessageIdMultisigIsm(ctx context.Context, in *MsgCreateMessageIdMultisigIsm, opts ...grpc.CallOption) (*MsgCreateMessageIdMultisigIsmResponse, error) {
	out := new(MsgCreateMessageIdMultisigIsmResponse)
	err := c.cc.Invoke(ctx, "/hyperlane.core.interchain_security.v1.Msg/CreateMessageIdMultisigIsm", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CreateMerkleRootMultisigIsm(ctx context.Context, in *MsgCreateMerkleRootMultisigIsm, opts ...grpc.CallOption) (*MsgCreateMerkleRootMultisigIsmResponse, error) {
	out := new(MsgCreateMerkleRootMultisigIsmResponse)
	err := c.cc.Invoke(ctx, "/hyperlane.core.interchain_security.v1.Msg/CreateMerkleRootMultisigIsm", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CreateNoopIsm(ctx context.Context, in *MsgCreateNoopIsm, opts ...grpc.CallOption) (*MsgCreateNoopIsmResponse, error) {
	out := new(MsgCreateNoopIsmResponse)
	err := c.cc.Invoke(ctx, "/hyperlane.core.interchain_security.v1.Msg/CreateNoopIsm", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CreateRoutingIsm(ctx context.Context, in *MsgCreateRoutingIsm, opts ...grpc.CallOption) (*MsgCreateRoutingIsmResponse, error) {
	out := new(MsgCreateRoutingIsmResponse)
	err := c.cc.Invoke(ctx, "/hyperlane.core.interchain_security.v1.Msg/CreateRoutingIsm", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SetRoutingIsmDomain(ctx context.Context, in *MsgSetRoutingIsmDomain, opts ...grpc.CallOption) (*MsgSetRoutingIsmDomainResponse, error) {
	out := new(MsgSetRoutingIsmDomainResponse)
	err := c.cc.Invoke(ctx, "/hyperlane.core.interchain_security.v1.Msg/SetRoutingIsmDomain", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RemoveRoutingIsmDomain(ctx context.Context, in *MsgRemoveRoutingIsmDomain, opts ...grpc.CallOption) (*MsgRemoveRoutingIsmDomainResponse, error) {
	out := new(MsgRemoveRoutingIsmDomainResponse)
	err := c.cc.Invoke(ctx, "/hyperlane.core.interchain_security.v1.Msg/RemoveRoutingIsmDomain", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateRoutingIsmOwner(ctx context.Context, in *MsgUpdateRoutingIsmOwner, opts ...grpc.CallOption) (*MsgUpdateRoutingIsmOwnerResponse, error) {
	out := new(MsgUpdateRoutingIsmOwnerResponse)
	err := c.cc.Invoke(ctx, "/hyperlane.core.interchain_security.v1.Msg/UpdateRoutingIsmOwner", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) AnnounceValidator(ctx context.Context, in *MsgAnnounceValidator, opts ...grpc.CallOption) (*MsgAnnounceValidatorResponse, error) {
	out := new(MsgAnnounceValidatorResponse)
	err := c.cc.Invoke(ctx, "/hyperlane.core.interchain_security.v1.Msg/AnnounceValidator", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CreateAggregationIsm(ctx context.Context, in *MsgCreateAggregationIsm, opts ...grpc.CallOption) (*MsgCreateAggregationIsmResponse, error) {
	out := new(MsgCreateAggregationIsmResponse)
	err := c.cc.Invoke(ctx, "/hyperlane.core.interchain_security.v1.Msg/CreateAggregationIsm", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SetAggregationIsmModules(ctx context.Context, in *MsgSetAggregationIsmModules, opts ...grpc.CallOption) (*MsgSetAggregationIsmModulesResponse, error) {
	out := new(MsgSetAggregationIsmModulesResponse)
	err := c.cc.Invoke(ctx, "/hyperlane.core.interchain_security.v1.Msg/SetAggregationIsmModules", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateAggregationIsmOwner(ctx context.Context, in *MsgUpdateAggregationIsmOwner, opts ...grpc.CallOption) (*MsgUpdateAggregationIsmOwnerResponse, error) {
	out := new(MsgUpdateAggregationIsmOwnerResponse)
	err := c.cc.Invoke(ctx, "/hyperlane.core.interchain_security.v1.Msg/UpdateAggregationIsmOwner", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
	// CreateMessageIdMultisigIsm ...
	CreateMessageIdMultisigIsm(context.Context, *MsgCreateMessageIdMultisigIsm) (*MsgCreateMessageIdMultisigIsmResponse, error)
	// CreateMerkleRootMultisigIsm ...
	CreateMerkleRootMultisigIsm(context.Context, *MsgCreateMerkleRootMultisigIsm) (*MsgCreateMerkleRootMultisigIsmResponse, error)
	// CreateNoopIsm ...
	CreateNoopIsm(context.Context, *MsgCreateNoopIsm) (*MsgCreateNoopIsmResponse, error)
	// CreateRoutingIsm ...
	CreateRoutingIsm(context.Context, *MsgCreateRoutingIsm) (*MsgCreateRoutingIsmResponse, error)
	// SetRoutingIsmDomain ...
	SetRoutingIsmDomain(context.Context, *MsgSetRoutingIsmDomain) (*MsgSetRoutingIsmDomainResponse, error)
	// RemoveRoutingIsmDomain ...
	RemoveRoutingIsmDomain(context.Context, *MsgRemoveRoutingIsmDomain) (*MsgRemoveRoutingIsmDomainResponse, error)
	// UpdateRoutingIsmOwner ...
	UpdateRoutingIsmOwner(context.Context, *MsgUpdateRoutingIsmOwner) (*MsgUpdateRoutingIsmOwnerResponse, error)
	// AnnounceValidator ...
	AnnounceValidator(context.Context, *MsgAnnounceValidator) (*MsgAnnounceValidatorResponse, error)
	// CreateAggregationIsm creates a new Aggregation ISM that requires a
	// threshold of child ISMs to pass verification. The creator becomes the owner
	// of the ISM. Emits EventCreateAggregationIsm on success.
	CreateAggregationIsm(context.Context, *MsgCreateAggregationIsm) (*MsgCreateAggregationIsmResponse, error)
	// SetAggregationIsmModules updates the modules and threshold of an existing
	// Aggregation ISM. Only the owner can perform this operation.
	// Emits EventSetAggregationIsmModules on success.
	SetAggregationIsmModules(context.Context, *MsgSetAggregationIsmModules) (*MsgSetAggregationIsmModulesResponse, error)
	// UpdateAggregationIsmOwner transfers ownership of an Aggregation ISM to a
	// new address or renounces ownership entirely. Only the current owner can
	// perform this operation. Emits EventSetAggregationIsm on success.
	UpdateAggregationIsmOwner(context.Context, *MsgUpdateAggregationIsmOwner) (*MsgUpdateAggregationIsmOwnerResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) CreateMessageIdMultisigIsm(ctx context.Context, req *MsgCreateMessageIdMultisigIsm) (*MsgCreateMessageIdMultisigIsmResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateMessageIdMultisigIsm not implemented")
}
func (*UnimplementedMsgServer) CreateMerkleRootMultisigIsm(ctx context.Context, req *MsgCreateMerkleRootMultisigIsm) (*MsgCreateMerkleRootMultisigIsmResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateMerkleRootMultisigIsm not implemented")
}
func (*UnimplementedMsgServer) CreateNoopIsm(ctx context.Context, req *MsgCreateNoopIsm) (*MsgCreateNoopIsmResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateNoopIsm not implemented")
}
func (*UnimplementedMsgServer) CreateRoutingIsm(ctx context.Context, req *MsgCreateRoutingIsm) (*MsgCreateRoutingIsmResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateRoutingIsm not implemented")
}
func (*UnimplementedMsgServer) SetRoutingIsmDomain(ctx context.Context, req *MsgSetRoutingIsmDomain) (*MsgSetRoutingIsmDomainResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetRoutingIsmDomain not implemented")
}
func (*UnimplementedMsgServer) RemoveRoutingIsmDomain(ctx context.Context, req *MsgRemoveRoutingIsmDomain) (*MsgRemoveRoutingIsmDomainResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveRoutingIsmDomain not implemented")
}
func (*UnimplementedMsgServer) UpdateRoutingIsmOwner(ctx context.Context, req *MsgUpdateRoutingIsmOwner) (*MsgUpdateRoutingIsmOwnerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateRoutingIsmOwner not implemented")
}
func (*UnimplementedMsgServer) AnnounceValidator(ctx context.Context, req *MsgAnnounceValidator) (*MsgAnnounceValidatorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AnnounceValidator not implemented")
}
func (*UnimplementedMsgServer) CreateAggregationIsm(ctx context.Context, req *MsgCreateAggregationIsm) (*MsgCreateAggregationIsmResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAggregationIsm not implemented")
}
func (*UnimplementedMsgServer) SetAggregationIsmModules(ctx context.Context, req *MsgSetAggregationIsmModules) (*MsgSetAggregationIsmModulesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetAggregationIsmModules not implemented")
}
func (*UnimplementedMsgServer) UpdateAggregationIsmOwner(ctx context.Context, req *MsgUpdateAggregationIsmOwner) (*MsgUpdateAggregationIsmOwnerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateAggregationIsmOwner not implemented")
}

func RegisterMsgServer(s grpc1.Server, srv MsgServer) {
	s.RegisterService(&_Msg_serviceDesc, srv)
}

func _Msg_CreateMessageIdMultisigIsm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateMessageIdMultisigIsm)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateMessageIdMultisigIsm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hyperlane.core.interchain_security.v1.Msg/CreateMessageIdMultisigIsm",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateMessageIdMultisigIsm(ctx, req.(*MsgCreateMessageIdMultisigIsm))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CreateMerkleRootMultisigIsm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateMerkleRootMultisigIsm)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateMerkleRootMultisigIsm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hyperlane.core.interchain_security.v1.Msg/CreateMerkleRootMultisigIsm",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateMerkleRootMultisigIsm(ctx, req.(*MsgCreateMerkleRootMultisigIsm))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CreateNoopIsm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateNoopIsm)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateNoopIsm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hyperlane.core.interchain_security.v1.Msg/CreateNoopIsm",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateNoopIsm(ctx, req.(*MsgCreateNoopIsm))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CreateRoutingIsm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateRoutingIsm)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateRoutingIsm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hyperlane.core.interchain_security.v1.Msg/CreateRoutingIsm",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateRoutingIsm(ctx, req.(*MsgCreateRoutingIsm))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SetRoutingIsmDomain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSetRoutingIsmDomain)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SetRoutingIsmDomain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hyperlane.core.interchain_security.v1.Msg/SetRoutingIsmDomain",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SetRoutingIsmDomain(ctx, req.(*MsgSetRoutingIsmDomain))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RemoveRoutingIsmDomain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRemoveRoutingIsmDomain)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RemoveRoutingIsmDomain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hyperlane.core.interchain_security.v1.Msg/RemoveRoutingIsmDomain",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RemoveRoutingIsmDomain(ctx, req.(*MsgRemoveRoutingIsmDomain))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateRoutingIsmOwner_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateRoutingIsmOwner)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateRoutingIsmOwner(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hyperlane.core.interchain_security.v1.Msg/UpdateRoutingIsmOwner",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateRoutingIsmOwner(ctx, req.(*MsgUpdateRoutingIsmOwner))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_AnnounceValidator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgAnnounceValidator)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).AnnounceValidator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hyperlane.core.interchain_security.v1.Msg/AnnounceValidator",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).AnnounceValidator(ctx, req.(*MsgAnnounceValidator))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CreateAggregationIsm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateAggregationIsm)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateAggregationIsm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hyperlane.core.interchain_security.v1.Msg/CreateAggregationIsm",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateAggregationIsm(ctx, req.(*MsgCreateAggregationIsm))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SetAggregationIsmModules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSetAggregationIsmModules)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SetAggregationIsmModules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hyperlane.core.interchain_security.v1.Msg/SetAggregationIsmModules",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SetAggregationIsmModules(ctx, req.(*MsgSetAggregationIsmModules))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateAggregationIsmOwner_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateAggregationIsmOwner)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateAggregationIsmOwner(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hyperlane.core.interchain_security.v1.Msg/UpdateAggregationIsmOwner",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateAggregationIsmOwner(ctx, req.(*MsgUpdateAggregationIsmOwner))
	}
	return interceptor(ctx, in, info, handler)
}

var Msg_serviceDesc = _Msg_serviceDesc
var _Msg_serviceDesc = grpc.ServiceDesc{
	ServiceName: "hyperlane.core.interchain_security.v1.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateMessageIdMultisigIsm",
			Handler:    _Msg_CreateMessageIdMultisigIsm_Handler,
		},
		{
			MethodName: "CreateMerkleRootMultisigIsm",
			Handler:    _Msg_CreateMerkleRootMultisigIsm_Handler,
		},
		{
			MethodName: "CreateNoopIsm",
			Handler:    _Msg_CreateNoopIsm_Handler,
		},
		{
			MethodName: "CreateRoutingIsm",
			Handler:    _Msg_CreateRoutingIsm_Handler,
		},
		{
			MethodName: "SetRoutingIsmDomain",
			Handler:    _Msg_SetRoutingIsmDomain_Handler,
		},
		{
			MethodName: "RemoveRoutingIsmDomain",
			Handler:    _Msg_RemoveRoutingIsmDomain_Handler,
		},
		{
			MethodName: "UpdateRoutingIsmOwner",
			Handler:    _Msg_UpdateRoutingIsmOwner_Handler,
		},
		{
			MethodName: "AnnounceValidator",
			Handler:    _Msg_AnnounceValidator_Handler,
		},
		{
			MethodName: "CreateAggregationIsm",
			Handler:    _Msg_CreateAggregationIsm_Handler,
		},
		{
			MethodName: "SetAggregationIsmModules",
			Handler:    _Msg_SetAggregationIsmModules_Handler,
		},
		{
			MethodName: "UpdateAggregationIsmOwner",
			Handler:    _Msg_UpdateAggregationIsmOwner_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "hyperlane/core/interchain_security/v1/tx.proto",
}

func (m *MsgCreateMessageIdMultisigIsm) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateMessageIdMultisigIsm) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateMessageIdMultisigIsm) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Threshold != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Threshold))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Validators) > 0 {
		for iNdEx := len(m.Validators) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Validators[iNdEx])
			copy(dAtA[i:], m.Validators[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.Validators[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateMessageIdMultisigIsmResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateMessageIdMultisigIsmResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateMessageIdMultisigIsmResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Id.Size()
		i -= size
		if _, err := m.Id.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgCreateMerkleRootMultisigIsm) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateMerkleRootMultisigIsm) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateMerkleRootMultisigIsm) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Threshold != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Threshold))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Validators) > 0 {
		for iNdEx := len(m.Validators) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Validators[iNdEx])
			copy(dAtA[i:], m.Validators[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.Validators[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateMerkleRootMultisigIsmResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateMerkleRootMultisigIsmResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateMerkleRootMultisigIsmResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Id.Size()
		i -= size
		if _, err := m.Id.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgCreateNoopIsm) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateNoopIsm) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateNoopIsm) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateNoopIsmResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateNoopIsmResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateNoopIsmResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Id.Size()
		i -= size
		if _, err := m.Id.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgAnnounceValidator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAnnounceValidator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAnnounceValidator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0x2a
	}
	{
		size := m.MailboxId.Size()
		i -= size
		if _, err := m.MailboxId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.StorageLocation) > 0 {
		i -= len(m.StorageLocation)
		copy(dAtA[i:], m.StorageLocation)
		i = encodeVarintTx(dAtA, i, uint64(len(m.StorageLocation)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Validator) > 0 {
		i -= len(m.Validator)
		copy(dAtA[i:], m.Validator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Validator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgAnnounceValidatorResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAnnounceValidatorResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAnnounceValidatorResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgCreateRoutingIsm) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateRoutingIsm) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateRoutingIsm) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Routes) > 0 {
		for iNdEx := len(m.Routes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Routes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateRoutingIsmResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateRoutingIsmResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateRoutingIsmResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Id.Size()
		i -= size
		if _, err := m.Id.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgSetRoutingIsmDomain) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetRoutingIsmDomain) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetRoutingIsmDomain) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.Route.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.IsmId.Size()
		i -= size
		if _, err := m.IsmId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgSetRoutingIsmDomainResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetRoutingIsmDomainResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetRoutingIsmDomainResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgRemoveRoutingIsmDomain) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRemoveRoutingIsmDomain) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRemoveRoutingIsmDomain) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Domain != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Domain))
		i--
		dAtA[i] = 0x10
	}
	{
		size := m.IsmId.Size()
		i -= size
		if _, err := m.IsmId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgRemoveRoutingIsmDomainResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRemoveRoutingIsmDomainResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRemoveRoutingIsmDomainResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgUpdateRoutingIsmOwner) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateRoutingIsmOwner) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateRoutingIsmOwner) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RenounceOwnership {
		i--
		if m.RenounceOwnership {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.NewOwner) > 0 {
		i -= len(m.NewOwner)
		copy(dAtA[i:], m.NewOwner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NewOwner)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x12
	}
	{
		size := m.IsmId.Size()
		i -= size
		if _, err := m.IsmId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgUpdateRoutingIsmOwnerResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateRoutingIsmOwnerResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateRoutingIsmOwnerResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgCreateAggregationIsm) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateAggregationIsm) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateAggregationIsm) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Threshold != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Threshold))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Modules) > 0 {
		for iNdEx := len(m.Modules) - 1; iNdEx >= 0; iNdEx-- {
			{
				size := m.Modules[iNdEx].Size()
				i -= size
				if _, err := m.Modules[iNdEx].MarshalTo(dAtA[i:]); err != nil {
					return 0, err
				}
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateAggregationIsmResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateAggregationIsmResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateAggregationIsmResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Id.Size()
		i -= size
		if _, err := m.Id.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgSetAggregationIsmModules) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetAggregationIsmModules) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetAggregationIsmModules) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x22
	}
	if m.Threshold != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Threshold))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Modules) > 0 {
		for iNdEx := len(m.Modules) - 1; iNdEx >= 0; iNdEx-- {
			{
				size := m.Modules[iNdEx].Size()
				i -= size
				if _, err := m.Modules[iNdEx].MarshalTo(dAtA[i:]); err != nil {
					return 0, err
				}
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size := m.IsmId.Size()
		i -= size
		if _, err := m.IsmId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgSetAggregationIsmModulesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetAggregationIsmModulesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetAggregationIsmModulesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgUpdateAggregationIsmOwner) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateAggregationIsmOwner) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateAggregationIsmOwner) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RenounceOwnership {
		i--
		if m.RenounceOwnership {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.NewOwner) > 0 {
		i -= len(m.NewOwner)
		copy(dAtA[i:], m.NewOwner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NewOwner)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x12
	}
	{
		size := m.IsmId.Size()
		i -= size
		if _, err := m.IsmId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgUpdateAggregationIsmOwnerResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateAggregationIsmOwnerResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateAggregationIsmOwnerResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgCreateMessageIdMultisigIsm) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Validators) > 0 {
		for _, s := range m.Validators {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.Threshold != 0 {
		n += 1 + sovTx(uint64(m.Threshold))
	}
	return n
}

func (m *MsgCreateMessageIdMultisigIsmResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Id.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgCreateMerkleRootMultisigIsm) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Validators) > 0 {
		for _, s := range m.Validators {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.Threshold != 0 {
		n += 1 + sovTx(uint64(m.Threshold))
	}
	return n
}

func (m *MsgCreateMerkleRootMultisigIsmResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Id.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgCreateNoopIsm) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgCreateNoopIsmResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Id.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgAnnounceValidator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Validator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.StorageLocation)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.MailboxId.Size()
	n += 1 + l + sovTx(uint64(l))
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgAnnounceValidatorResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgCreateRoutingIsm) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Routes) > 0 {
		for _, e := range m.Routes {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgCreateRoutingIsmResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Id.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgSetRoutingIsmDomain) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.IsmId.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.Route.Size()
	n += 1 + l + sovTx(uint64(l))
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgSetRoutingIsmDomainResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgRemoveRoutingIsmDomain) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.IsmId.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.Domain != 0 {
		n += 1 + sovTx(uint64(m.Domain))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgRemoveRoutingIsmDomainResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgUpdateRoutingIsmOwner) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.IsmId.Size()
	n += 1 + l + sovTx(uint64(l))
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.NewOwner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.RenounceOwnership {
		n += 2
	}
	return n
}

func (m *MsgUpdateRoutingIsmOwnerResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgCreateAggregationIsm) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Modules) > 0 {
		for _, e := range m.Modules {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.Threshold != 0 {
		n += 1 + sovTx(uint64(m.Threshold))
	}
	return n
}

func (m *MsgCreateAggregationIsmResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Id.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgSetAggregationIsmModules) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.IsmId.Size()
	n += 1 + l + sovTx(uint64(l))
	if len(m.Modules) > 0 {
		for _, e := range m.Modules {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.Threshold != 0 {
		n += 1 + sovTx(uint64(m.Threshold))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgSetAggregationIsmModulesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgUpdateAggregationIsmOwner) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.IsmId.Size()
	n += 1 + l + sovTx(uint64(l))
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.NewOwner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.RenounceOwnership {
		n += 2
	}
	return n
}

func (m *MsgUpdateAggregationIsmOwnerResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTx(x uint64) (n int) {
	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgCreateMessageIdMultisigIsm) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateMessageIdMultisigIsm: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateMessageIdMultisigIsm: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validators", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validators = append(m.Validators, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threshold", wireType)
			}
			m.Threshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Threshold |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateMessageIdMultisigIsmResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateMessageIdMultisigIsmResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateMessageIdMultisigIsmResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateMerkleRootMultisigIsm) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateMerkleRootMultisigIsm: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateMerkleRootMultisigIsm: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validators", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validators = append(m.Validators, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threshold", wireType)
			}
			m.Threshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Threshold |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateMerkleRootMultisigIsmResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateMerkleRootMultisigIsmResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateMerkleRootMultisigIsmResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateNoopIsm) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateNoopIsm: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateNoopIsm: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateNoopIsmResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateNoopIsmResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateNoopIsmResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAnnounceValidator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAnnounceValidator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAnnounceValidator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageLocation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageLocation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MailboxId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MailboxId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAnnounceValidatorResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAnnounceValidatorResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAnnounceValidatorResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateRoutingIsm) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateRoutingIsm: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateRoutingIsm: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Routes = append(m.Routes, Route{})
			if err := m.Routes[len(m.Routes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateRoutingIsmResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateRoutingIsmResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateRoutingIsmResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetRoutingIsmDomain) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetRoutingIsmDomain: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetRoutingIsmDomain: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsmId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.IsmId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Route", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Route.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetRoutingIsmDomainResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetRoutingIsmDomainResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetRoutingIsmDomainResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRemoveRoutingIsmDomain) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRemoveRoutingIsmDomain: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRemoveRoutingIsmDomain: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsmId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.IsmId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			m.Domain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Domain |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRemoveRoutingIsmDomainResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRemoveRoutingIsmDomainResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRemoveRoutingIsmDomainResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateRoutingIsmOwner) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateRoutingIsmOwner: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateRoutingIsmOwner: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsmId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.IsmId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewOwner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewOwner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RenounceOwnership", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RenounceOwnership = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateRoutingIsmOwnerResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateRoutingIsmOwnerResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateRoutingIsmOwnerResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateAggregationIsm) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateAggregationIsm: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateAggregationIsm: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Modules", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_bcp_innovations_hyperlane_cosmos_util.HexAddress
			m.Modules = append(m.Modules, v)
			if err := m.Modules[len(m.Modules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threshold", wireType)
			}
			m.Threshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Threshold |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateAggregationIsmResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateAggregationIsmResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateAggregationIsmResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetAggregationIsmModules) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetAggregationIsmModules: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetAggregationIsmModules: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsmId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.IsmId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Modules", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_bcp_innovations_hyperlane_cosmos_util.HexAddress
			m.Modules = append(m.Modules, v)
			if err := m.Modules[len(m.Modules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threshold", wireType)
			}
			m.Threshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Threshold |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetAggregationIsmModulesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetAggregationIsmModulesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetAggregationIsmModulesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateAggregationIsmOwner) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateAggregationIsmOwner: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateAggregationIsmOwner: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsmId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.IsmId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewOwner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewOwner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RenounceOwnership", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RenounceOwnership = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateAggregationIsmOwnerResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateAggregationIsmOwnerResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateAggregationIsmOwnerResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTx
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTx
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTx
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
